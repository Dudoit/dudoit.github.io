import{_ as o}from"./chunks/cdnImg.vue_vue_type_style_index_0_lang.c2480eb1.js";import{o as p,c as l,z as s,G as e,O as n,a}from"./chunks/framework.a3f41f98.js";const t=n(`<h1 id="javascript" tabindex="-1">JavaScript <a class="header-anchor" href="#javascript" aria-label="Permalink to &quot;JavaScript&quot;">​</a></h1><h2 id="javascript-的内置类型" tabindex="-1">JavaScript 的内置类型 <a class="header-anchor" href="#javascript-的内置类型" aria-label="Permalink to &quot;JavaScript 的内置类型&quot;">​</a></h2><p><code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>bigint</code>、<code>symbol</code>、<code>object</code></p><p>除了 <code>object</code> 为复杂类型，其他都是基本类型</p><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><ul><li><p>什么是闭包？</p><p>闭包：是指能够访问自由变量的函数（自由变量是指外部作用域中的变量）</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">debounce</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">delay</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 自由变量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">_debounce</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">delay</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></li><li><p>闭包的作用及常见用途</p><p>作用：私有化数据，保护变量，延迟变量的生命周期</p><p>用途：防抖、节流、Vue 响应式原理</p></li><li><p>闭包的缺点及解决方案</p><p>缺点：可能会导致内存泄露，内部变量不被回收</p><p>解决方案：在变量不被使用时，将值设置为 <code>null</code></p></li></ul><h2 id="原型-原型链" tabindex="-1">原型 &amp; 原型链 <a class="header-anchor" href="#原型-原型链" aria-label="Permalink to &quot;原型 &amp; 原型链&quot;">​</a></h2>`,7),c=n(`<p>原型</p><p>1）对象的原型</p><p>对象的内置属性 <code>[[Prototype]]</code>，可以使用 <code>__proto__</code> 或 <code>Object.getPrototypeOf()</code> 获取属性值</p><p>2）函数的原型</p><p>由于函数也是特殊的对象，函数上也有一个属性 <code>prototype</code>，可以直接使用 <code>Function.prototype</code> 获取</p><p>通过 new 关键字创建对象时，对象内部的 <code>[[Prototype]]</code> 属性就会被函数的 <code>prototype</code> 赋值</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> p1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> p2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">p1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> p2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#A6ACCD;">p1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p><code>Function.prototype.constructor</code> 指向当前函数对象</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor)  </span><span style="color:#676E95;font-style:italic;">// [Function: Person]</span></span></code></pre></div>`,9),r=s("li",null,[s("p",null,"原型链"),s("p",null,[a("访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，这样一直找下去，就是原型链的概念。原型链的尽头一般来说都是 "),s("code",null,"Object.prototype"),a(" 所以这就是我们新建的对象为什么能够使用 "),s("code",null,"toString()"),a(" 等方法的原因")])],-1),i=n(`<h2 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h2><p><code>this</code> 对象是执行上下文中的一个属性，通常在函数中使用</p><p>在全局调用函数时，<code>this</code> 指向 window，当被作为方法调用时，<code>this</code> 指向调用者</p><p><code>call</code>、<code>apply</code>、<code>bind</code> 可显式地指定 <code>this</code> 的指向</p><p>绑定优先级：显式绑定 &gt; new &gt; bind &gt; 隐式绑定 &gt; 默认绑定</p><h2 id="new" tabindex="-1">new <a class="header-anchor" href="#new" aria-label="Permalink to &quot;new&quot;">​</a></h2><ol><li>创建一个新的空对象</li><li>设置原型，将函数的 <code>prototype</code> 赋值给对象的原型</li><li>让函数的 this 执行这个对象，执行构造函数</li><li>判断函数的返回值类型，值类型就返回创建的对象，引用类型就返回引用类型的对象</li></ol><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h2><ul><li><p>通过原型链的方式继承</p><p>缺点：如果包含引用类型的数据，会被所有的实例对象所共享，容易造成修改的混乱</p></li><li><p>借用构造函数</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Student</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Student</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span></code></pre></div><p>缺点：会调用两次父类构造函数，子类中会多出不必要的属性</p></li><li><p>原型式继承</p></li><li><p>寄生式继承</p></li><li><p>寄生组合式继承</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">object</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">o</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">F</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">inheritPrototype</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">subType</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">superType</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">subType</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">object</span><span style="color:#F07178;">(</span><span style="color:#FFCB6B;">superType</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">subType</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subType</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">inheritPrototype</span><span style="color:#A6ACCD;">(Student</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Person)</span></span></code></pre></div></li></ul><h2 id="eventloop" tabindex="-1">eventloop <a class="header-anchor" href="#eventloop" aria-label="Permalink to &quot;eventloop&quot;">​</a></h2><p>JavaScript 是单线程的脚本语言，为了防止一个函数的执行时间过长而阻塞后面的代码，所以 JavaScript 会区分同步任务和异步任务</p><p>执行同步任务时，JavaScript 会从执行栈中取出同步代码并顺序执行；</p><p>执行异步任务时，JavaScript 会将其转移到相应的任务队列中，而不是立即执行</p><p>任务队列又分 <strong>宏任务队列</strong> 和 <strong>微任务队列</strong></p><p><span class="blue-text">在执行 宏任务队列 中的代码时，要确保 微任务队列 已清空</span></p><table><thead><tr><th>任务队列</th><th></th></tr></thead><tbody><tr><td>宏任务</td><td>script（整体代码）、setTimout、setInterval、<br>setImmediate(node 独有)、requestAnimationFrame(浏览器独有)、<br>IO、UI render（浏览器独有）</td></tr><tr><td>微任务</td><td>process.nextTick(node 独有)、<br>Promise.then()、Object.observe、MutationObserver</td></tr></tbody></table><div class="info custom-block"><p class="custom-block-title">Node.js 和 浏览器的 Event Loop 差异</p><ol><li>实现方式：浏览器由浏览器引擎实现；Node.js 则是由自身环境实现</li><li>事件类型：浏览器处理多种事件，用户交互、网络请求、定时器等；Node 多用来处理网络请求和异步操作，文件操作或数据库查询</li><li>执行上限：浏览器通常会持续执行知道用户关闭页面；Node 默认循环一次就退出，除非有定时器或监听器</li><li>宏任务：Node 中的宏任务又分为 timer 类型、check 类型、close callbacks 类型</li></ol></div><h2 id="ajax" tabindex="-1">AJAX <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;AJAX&quot;">​</a></h2><p>AJAX（Async JavaScript And XML），一种异步通信的方法，实现在不刷新页面的情况下从服务端获取数据</p><p>XMLHttpRequest 的属性和方法：</p><ul><li><p><code>open()</code>：接收请求类型、请求地址、是否异步</p></li><li><p><code>send()</code>：发送请求到服务器</p></li><li><p><code>onreadystatechange()</code>：监听请求进度，即 <code>readyState</code> 属性</p></li><li><p><code>abort()</code>：响应前取消异步请求</p></li></ul><div class="info custom-block"><p class="custom-block-title">readyState 值说明</p><p>0：未初始化。尚未调用 open() 方法。 1：已打开。已调用 open() 方法，尚未调用 send() 方法。 2：已发送。已调用 send() 方法，尚未收到响应。 3：接收中。已经收到部分响应。 4：完成。已经收到所有响应，可以使用了。</p></div><h2 id="instanceof-的原理" tabindex="-1">instanceof 的原理 <a class="header-anchor" href="#instanceof-的原理" aria-label="Permalink to &quot;instanceof 的原理&quot;">​</a></h2><p>判断对象的 <i class="purple-text">原型链</i> 中是否能找到类型的 prototype</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myInstanceof</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">type</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">type</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="var、let、const-的区别" tabindex="-1">var、let、const 的区别 <a class="header-anchor" href="#var、let、const-的区别" aria-label="Permalink to &quot;var、let、const 的区别&quot;">​</a></h2><ul><li><p>var 的特点</p><p>var 遵循函数作用域，创建在全局创建的变量能用 <code>window.</code> 获取</p><p>var 可以重复声明</p></li><li><p>let &amp; const 的相同点</p><p>在同一块级作用域内，<span class="blue-text">不允许重复声明</span></p><p>不存在变量提升，只能在定义后使用</p><p>暂时性死区：只要块级作用域中存在变量声明，它们所声明的变量就绑定这个区域不受外部影响，例如：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">resetValue</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">120</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ReferenceError: Cannot access &#39;value&#39; before initialization</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></li><li><p>const 的特点</p><p><code>const</code> 声明时就要立即赋值；且值为只读常量，一旦声明就不允许修改</p></li></ul><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h2><p>箭头函数是匿名函数，不能作为构造函数，不能使用 new</p><p>箭头函数的 this 指向定义箭头函数上下文中的 this，任何方法都无法改变它的指向</p><p>箭头函数没有原型属性</p><p>箭头函数没有 arguments 对象，需要使用剩余参数获取参数列表</p><h2 id="promise" tabindex="-1">promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;promise&quot;">​</a></h2><p>Promise 是处理异步请求的一种方式，比传统的解决方案（回调函数）更优</p><p>Promise 是一个容器，保存着未来才会结束的事件</p><p>特点：创建后立即执行；状态一旦改变，不能再次变更</p><p>三种状态：pedding、fulfilled、rejected</p><ul><li><p>优点和缺点</p><p>优点：Promise 提供统一的规范，实用性更强；链式调用避免了回调地狱的发生</p><p>缺点：Promise 一旦创建就会立即执行，无法取消；当 Promise 处于 pedding 时，无法得知是哪个阶段</p></li><li><p>all、allSettled、race、any</p><p>all：所有结果都成功时返回，否则返回失败的结果</p><p>allSettled：返回所有的结果</p><p>race：返回最先完成的结果</p><p>any：返回最先成功的结果</p></li></ul><h3 id="then-方法的第二个回调和-catch-有什么不同" tabindex="-1">then 方法的第二个回调和 catch 有什么不同 <a class="header-anchor" href="#then-方法的第二个回调和-catch-有什么不同" aria-label="Permalink to &quot;then 方法的第二个回调和 catch 有什么不同&quot;">​</a></h3><p><code>then()</code> 的回调不能捕获第一个回调函数中抛出的错误，<code>catch()</code> 可以</p><h2 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h2><p>async/await 也是异步编程的一种解决方案，它遵循的是 Generator 的语法糖，不需要额外调用即可执行，返回的是 Promise 对象</p><h2 id="class-关键字和-function-的区别" tabindex="-1">class 关键字和 function 的区别 <a class="header-anchor" href="#class-关键字和-function-的区别" aria-label="Permalink to &quot;class 关键字和 function 的区别&quot;">​</a></h2><ul><li><p>this</p><p><code>function</code> 可以使用 call、apply、bind 的方式指定它的执行上下文</p><p><code>class</code> 内部做了代理，禁止了这种行为</p></li><li><p>constructor</p><p><code>function</code> 中的 <code>prototype.constructor</code> 属性指向函数自身</p><p><code>class</code> 中 <code>constructor</code> 相当于定义在 <code>prototype</code> 上的一个属性</p></li><li><p>重复定义</p><p><code>function</code> 允许重复定义；<code>class</code> 不允许重复定义</p></li><li><p>枚举</p><p><code>class</code> 中定义的方法不可用 <code>Object.keys(Point.prototype)</code> 枚举到</p><p><code>function</code> 构造器原型方法可被 <code>Object.keys(Point.prototype)</code> 枚举到</p></li></ul>`,44),h=JSON.parse('{"title":"JavaScript","description":"","frontmatter":{},"headers":[],"relativePath":"develop/Work+Algorithm/Offer/javascript.md","filePath":"develop/Work+Algorithm/Offer/javascript.md"}'),y={name:"develop/Work+Algorithm/Offer/javascript.md"},u=Object.assign(y,{setup(F){return(D,d)=>(p(),l("div",null,[t,s("ul",null,[s("li",null,[c,e(o,{src:"offer-javascript-proto"})]),r]),i]))}});export{h as __pageData,u as default};
