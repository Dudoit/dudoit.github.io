import"./chunks/cdnImg.vue_vue_type_style_index_0_lang.4ed993c7.js";import{o as e,c as o,O as t}from"./chunks/framework.51846e02.js";const a=t(`<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h2><p><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写，也就是将 <code>MVC</code> 中的 <code>Controller</code> 演变为 <code>ViewModel</code>。</p><p><code>Model</code> 代表 <strong>数据模型</strong>；<code>View</code> 代表 <strong>视图组件</strong>；<code>ViewModel</code> 是一个同步 <code>View</code> 和 <code>Model</code> 的对象。</p><p>数据绑定到 <code>ViewModel</code> 并自动将数据渲染到页面中，视图变化会通知 <code>ViewModel</code> 更新数据。</p><h2 id="spa" tabindex="-1">SPA <a class="header-anchor" href="#spa" aria-label="Permalink to &quot;SPA&quot;">​</a></h2><p>SPA，单页面应用（Sigle Page Application）。是一种 WEB 应用程序的设计模式，就是只有一张 WEB 页面的应用。加载单个 HTML，通过动态加载内容而无需重新加载整个页面。</p><p>优势：</p><ol><li>减少了页面间的跳转，用户体验好</li><li>减少了一定的网络请求次数，减轻了服务端压力</li><li>渲染少部分需要更新的内容即可，减轻浏览器压力</li></ol><p>缺点：</p><ol><li>由于页面为动态生成，起初为 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> ，对 SEO 并不友好；</li><li>首次加载时间长，容易导致白屏。SPA 需要预加载所有资源，包括 JavaScript、CSS、模板</li></ol><p>解决方法：</p><ol><li>代码分割：将大型 JavaScript 代码拆分较小的分片</li><li>异步路由：延迟加载首屏非必需的内容</li><li>资源压缩</li><li>SSR 服务端渲染</li></ol><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">父子组件的执行顺序</p><p><span class="blue-text">父组件 beforeCreate -&gt; 父组件 created -&gt; 父组件 beforeMount</span> -&gt; 子组件 beforeCreate -&gt; 子组件 created -&gt; 子组件 beforeMount -&gt; 子组件 mounted -&gt; <span class="blue-text">父组件 mounted</span></p></div><h2 id="vue3-和-vue2-的差异" tabindex="-1">Vue3 和 Vue2 的差异 <a class="header-anchor" href="#vue3-和-vue2-的差异" aria-label="Permalink to &quot;Vue3 和 Vue2 的差异&quot;">​</a></h2><ul><li><p><strong>Composition API 和 Option API</strong></p><p>Composition API 根据逻辑的相关性组织代码，提升代码的可读性和可维护性，类似 react 的 hook 写法</p><p>Composition API 能更好地复用逻辑代码，在 Option API 通过使用 Mixins 复用代码，容易发生命名冲突的问题</p><p>Composition API 解决了在生命周期函数中不相关逻辑的抽离问题。例如在 mounted 中设置定时器，但是需要在 destroyed 中清除定时器，将同一逻辑分离到不同位置，造成后期代码维护困难。</p></li><li><p><strong>响应式原理</strong></p><p>Vue3 采用 ES6 的 <span class="blue-text">Proxy API</span> 重写响应式逻辑，劫持对象中属性的变化，再通过 <span class="blue-text">Reflect</span> 对源对象的属性进行操作。</p><p>优点：可以监听 动态新增/删除的属性，数组索引以及 length 属性</p><p>Vue2 中响应式系统的核心是 <code>Object.defineProperty</code>，劫持整个对象并深度遍历所有属性，给每个属性添加 getter 和 setter</p></li><li><p><strong>diff 算法</strong></p><p>Vue2 使用深度优先遍历：逐层对比 Virtual DOM 节点，找出差异并更新响应的组件</p><p>Vue3 使用静态标记：结合深度优先遍历和按需更新，在编译阶段将模板标记为 静态 和 动态。当动态节点发生变化时，使用深度优先遍历比较和更新</p></li><li><p><strong>生命周期钩子名称</strong></p><p>Vue2 中的 <code>destroyed</code> 钩子在 Vue3 中改为了 <code>unmounted</code></p></li><li><p><strong>根节点数量</strong></p><p>Vue2 中，每个组件只允许存在 1 个根节点；Vue3 则允许存在 多个节点</p></li><li><p><strong>对 TypeScript 的支持</strong></p><p>Vue3 提供了更好的类型推断和严格的类型检查，Composition API 也提升了 TypeScript 的开发体验</p></li></ul><h2 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h2><p>浏览器中操作 DOM 的代价比较昂贵，频繁操作 DOM 会产生性能问题</p><p>虚拟 DOM 的作用是在每一次响应式数据发生变化而引起页面重新渲染时，对比更新前后的虚拟 DOM ，找出需要更新的真实 DOM</p><p><a href="https://blog.csdn.net/liuliuliuliumin123/article/details/107943687" target="_blank" rel="noreferrer">https://blog.csdn.net/liuliuliuliumin123/article/details/107943687</a></p><h2 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h2><h2 id="key-的作用" tabindex="-1">Key 的作用 <a class="header-anchor" href="#key-的作用" aria-label="Permalink to &quot;Key 的作用&quot;">​</a></h2><ul><li><p>key 的使用场景</p><p>使用 <code>v-for</code> 进行列表渲染时，通常会给子项绑定 <code>key</code> 属性</p></li><li><p><code>key</code> 的作用</p><p>为了更高效地对比 <span class="blue-text">虚拟 DOM</span> 中每个节点是否为相同节点</p></li><li><p>key 的判断依据</p><p>Vue 在 patch 过程中判断两个节点是否为同一节点，<code>key</code> 是一个必要条件</p><p>使用 <code>key</code>，会基于 key 的变化重新排列元素顺序，进行更新、移动或删除；如果不使用 <code>key</code>，Vue 会尝试 修改/复用 同类型元素。</p></li><li><p>结论</p><p>diff 算法过程中，会先进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的 key 与旧节点比对，算出差异；所以使用 <code>key</code>，可以有效提高 diff 算法性能，避免重复渲染和更新无关的组件和元素</p></li></ul><div class="warning custom-block"><p class="custom-block-title">不建议使用索引 index</p><p>index 会随着数组的变化而变化，所以本质上并不能真正地定义 nodes 。所以使用 index 只能消除控制台警告，并不能利用 diff 算法达到更好的效果</p></div><h2 id="组件间的通讯方式" tabindex="-1">组件间的通讯方式 <a class="header-anchor" href="#组件间的通讯方式" aria-label="Permalink to &quot;组件间的通讯方式&quot;">​</a></h2><ul><li><p><strong><code>props</code>、<code>$emit</code></strong></p><p><code>props</code> 属性传递；<code>$emit</code> 发送事件</p></li><li><p><strong>依赖注入 <code>Provide</code>、<code>Inject</code></strong></p><p>祖先组件中通过 <code>provide</code> 提供依赖；子孙组件通过 <code>Inject</code> 注入依赖</p></li><li><p><strong>事件总线 <code>EventBus</code>、<code>Mitt</code></strong></p><p><code>EventBus</code> 使用 发布/订阅 模式，通过空的 Vue 实例作为事件总线，用来触发事件和监听事件</p><p>Vue3 中移除了 <code>$on</code>、<code>$off</code> 等方法，<code>EventBus</code> 不再使用，替换为 <code>mitt.js</code></p></li><li><p><strong>状态管理 <code>Vuex</code>、<code>Pinia</code></strong></p></li><li><p><strong><code>$root</code>、<code>$parent</code>、<code>$children</code></strong></p><p>访问 根组件、父组件、子组件 实例</p></li></ul><h2 id="双向绑定-v-model" tabindex="-1">双向绑定/v-model <a class="header-anchor" href="#双向绑定-v-model" aria-label="Permalink to &quot;双向绑定/v-model&quot;">​</a></h2><p><code>v-model</code> 是 Vue 的双向绑定指令，通常用在元素表单上。例如：<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>...</p><p><code>v-model</code> 双向绑定本质上是一种语法糖（value + event），用于监听输入事件以更新数据</p><div class="language-Vue"><button title="Copy Code" class="copy"></button><span class="lang">Vue</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- v-model 原理 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">search</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">input</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">search </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> $event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">/&gt;</span></span></code></pre></div><p><code>v-model</code> 也可以在 自定义组件 上使用，不过需要自定义 <code>prop</code> 和 <code>event</code></p><h2 id="setup" tabindex="-1">setup <a class="header-anchor" href="#setup" aria-label="Permalink to &quot;setup&quot;">​</a></h2><h3 id="setup-中如何获取组件实例" tabindex="-1">setup 中如何获取组件实例 <a class="header-anchor" href="#setup-中如何获取组件实例" aria-label="Permalink to &quot;setup 中如何获取组件实例&quot;">​</a></h3><p>在 vue2 中， Options API 可以使用 this 来获取组件的实例，但是到现在的 vue3 ，已经被摒弃掉了。在 setup 和其他 Composition API 中没有 this ，但是它提供了一个 getCurrentInstance 来获取当前的实例。</p><h2 id="slot-插槽" tabindex="-1">slot 插槽 <a class="header-anchor" href="#slot-插槽" aria-label="Permalink to &quot;slot 插槽&quot;">​</a></h2><ul><li><p>插槽的作用</p><p>让用户可以扩展组件，更好地 复用组件 和 定制化处理</p></li></ul>`,37),l=[a],r=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"develop/Interview/Offer/vue.md","filePath":"develop/Interview/Offer/vue.md"}'),s={name:"develop/Interview/Offer/vue.md"},u=Object.assign(s,{setup(p){return(c,d)=>(e(),o("div",null,l))}});export{r as __pageData,u as default};
