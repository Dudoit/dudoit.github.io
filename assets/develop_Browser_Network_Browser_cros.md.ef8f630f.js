import{_ as t,o,c as r,O as e}from"./chunks/framework.a3f41f98.js";const m=JSON.parse('{"title":"跨域","description":"","frontmatter":{},"headers":[],"relativePath":"develop/Browser+Network/Browser/cros.md","filePath":"develop/Browser+Network/Browser/cros.md"}'),n={name:"develop/Browser+Network/Browser/cros.md"},d=e('<h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h1><p>我们在刚刚开始学习AJAX、Node或者练习一些项目实战的时候，HTTP请求是获取动态数据的重要一环，我猜大家肯定都遇到过令人头疼的跨域问题，第一次出现非代码程序的报错会让我们不知道如何下手，项目也无法继续进行；通常百度会帮助我们很快的解决掉这个问题，虽然项目能够进行下去了，但是我们的思绪还是一团麻，不知道什么时候什么原因出现会出现这个报错，我们下面就来看一下怎么梳开这个疙瘩。</p><p>几个关键词总结文章：<code>跨域</code>、<code>浏览器</code>、<code>同源策略</code>、<code>CORS</code>、<code>代理服务</code>、<code>Nginx反向代理</code></p><h2 id="跨域是什么" tabindex="-1">跨域是什么？ <a class="header-anchor" href="#跨域是什么" aria-label="Permalink to &quot;跨域是什么？&quot;">​</a></h2><p>这还不简单？什么是跨域，开局一张图。</p><p>（跨域飘红报错）</p><p>从上图可以看出，我们网站为 <code>http://localhost:8080</code> 的地址无法从 <code>http://localhost:3000</code> 获取数据</p><p>这时你不服气了，啪，甩给我一张图，看这不是请求成功了吗</p><p>（从apifox/postman中请求成功的图片）</p><p>听我解释呀，我们从Postman、Apifox中调试接口时能顺利拿到服务端提供的数据，但在控制台却给我们报错了呢，这说明我们的客户端即 <strong>浏览器</strong> 不能执行 <code>http://localhost:3000</code> 的 脚本</p><h2 id="常见的跨域场景" tabindex="-1">常见的跨域场景 <a class="header-anchor" href="#常见的跨域场景" aria-label="Permalink to &quot;常见的跨域场景&quot;">​</a></h2><table><thead><tr><th><strong>URL</strong></th><th><strong>是否同域</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><a href="http://www.dudoit.com" target="_blank" rel="noreferrer">http://www.dudoit.com</a>/<strong>index.js</strong><br><a href="http://www.dudoit.com" target="_blank" rel="noreferrer">http://www.dudoit.com</a>/<strong>common.js</strong></td><td><strong>同域</strong></td><td>同一域名，同一文件夹</td></tr><tr><td><a href="http://www.dudoit.com" target="_blank" rel="noreferrer">http://www.dudoit.com</a>/<strong>a</strong>/index.js<br><a href="http://www.dudoit.com" target="_blank" rel="noreferrer">http://www.dudoit.com</a>/<strong>b</strong>/common.js</td><td><strong>同域</strong></td><td>同一域名，不同文件夹</td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br><a href="http://www.dudoit.com" target="_blank" rel="noreferrer">http://www.dudoit.com</a>:<strong>8000</strong>/common.js</td><td><strong>不同域</strong></td><td>同一域名，<strong>不同端口</strong> <br>[ http默认80端口 ]</td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br>http<strong>s</strong>://www.dudoit.com/common.js</td><td><strong>不同域</strong></td><td>同一域名，<strong>不同协议</strong></td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br>http://<strong>api</strong>.dudoit.com/common.js</td><td><strong>不同域</strong></td><td>主域名相同，<strong>子域名不同</strong></td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br>http://<strong>dudoit.com</strong>/common.js</td><td><strong>不同域</strong></td><td>同一域名，<strong>不同二级域名</strong></td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br>http://<strong>123.123.85.27</strong>/common.js</td><td><strong>不同域</strong></td><td>同一域名，<strong>对应的IP</strong></td></tr><tr><td><a href="http://www.dudoit.com/index.js" target="_blank" rel="noreferrer">http://www.dudoit.com/index.js</a><br>http://<strong>www.baidu.com</strong>/index.js</td><td><strong>不同域</strong></td><td><strong>不同域名</strong></td></tr></tbody></table><p>从上面的表格可以得知，共有 6 种情况会导致跨域的出现，分别是：</p><p>不同端口、不同协议、子域名不同、二级域名不同、不同域名、不同域（IP）</p><p>我们现在知道了xxx，那 <strong>浏览器</strong> 为什么不能执行不同域下即 跨域执行脚本 呢？</p><p>这是因为它自身携带了一本“防身指南”— <strong>同源策略</strong></p><p>它是指网址中的协议、域名、端口三个都相同时才能互相访问，即若协议、域名、端口有其一不同时，浏览器禁止页面加载或执行与自身不同域的脚本</p><p>同源策略 的存在能够帮助<strong>阻隔恶意文档</strong>，<strong>减少可能被攻击的媒介</strong>。如果没有同源策略，我们网站的cookie等信息可能泄露，cookie一般是与服务端会话的重要凭证，可能会出现数据被盗取等后果。</p><p>其实，不只是你的 AJAX 请求无法被浏览器接收，同源策略的限制内容包括：</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储在浏览器中的内容不能跨域访问</li><li>DOM 节点不能跨域操作</li><li>AJAX 请求被拦截</li></ul><h2 id="常见的跨域解决方法" tabindex="-1">常见的跨域解决方法 <a class="header-anchor" href="#常见的跨域解决方法" aria-label="Permalink to &quot;常见的跨域解决方法&quot;">​</a></h2><p>将静态资源和API接口部署在同一个服务器</p><h3 id="cors-跨域资源共享" tabindex="-1">CORS 跨域资源共享 <a class="header-anchor" href="#cors-跨域资源共享" aria-label="Permalink to &quot;CORS 跨域资源共享&quot;">​</a></h3><blockquote><p>跨源资源共享（CORS，或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。</p></blockquote><p>CORS，全称 Cross-Origin Resource Sharing，跨域资源共享。</p><p>开启CORS的关键主要是服务端通过设置 <code>Access-Control-Allow-Origin</code> 的值处理跨域问题；例如，</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Access-Control-Allow-Origin</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://www.example.com</span><span style="color:#89DDFF;">&quot;</span></span></code></pre></div><p>在我看来这个相当于前端赋予服务端的一个令牌，服务端拿着这个令牌给浏览器，浏览器看了有前端域名签名的令牌，哟~原来是自家兄dei，快来快来。<code>*</code> 就更牛逼了，就像满江红里秦桧给张大的通行证一样，哪个浏览器还能不放行。</p><p>浏览器会自动进行CORS通信，但是即便CORS主要是在服务端配置的，CORS也需要浏览器和服务器同时支持才可以；目前所有浏览器都支持，具体浏览器兼容性可查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7" target="_blank" rel="noreferrer">MDN文档</a>。</p><p>在面试中，CORS经常会拿来与JSONP做比较，它们两个的使用目的相同，但是CORS比JSONP更强大，看现在使用的频率就知道了。其次，在请求方式上，JSONP仅支持GET请求，而CORS支持所有类型的HTTP请求；在处理方式上，使用CORS，前端会非常开心，因为他不需要额外的改动；在兼容性方面，JSONP会更胜一筹。</p><h3 id="node-代理服务" tabindex="-1">Node 代理服务 <a class="header-anchor" href="#node-代理服务" aria-label="Permalink to &quot;Node 代理服务&quot;">​</a></h3><p>刚刚我们说了，同源策略是 <strong>浏览器</strong> 自身携带的“防身指南”；我们还说了，在Postman、Apifox等接口调试工具中都是可以完美请求到服务端传来的数据。那么，说明同为<strong>服务端向服务端</strong>请求就没有了同源策略的限制，- - 哈哈哈哈来来来都是“自家人”有什么可“防身”的，速速对酒当歌 🍻。</p><p>这里值得注意的是，<strong>前端</strong> 在请求 <strong>node代理</strong>服务时，由于端口不同或其他不同域的原因，还是会带上“防身指南”— 同源策略。所以，代理服务器 <strong>依然需要开启CORS</strong>，这样代理服务才能在拿到真实请求的数据后正确地返回给前端。</p><p>proxy</p><p>使用 node 进行</p><h3 id="nginx-反向代理" tabindex="-1">Nginx 反向代理 <a class="header-anchor" href="#nginx-反向代理" aria-label="Permalink to &quot;Nginx 反向代理&quot;">​</a></h3><p>Nginx反向代理一般在项目最后上线时在nginx服务器上开启；</p><p>开启方法和CORS跨域资源共享类似</p><p>在 Nginx 服务端上找到 default.conf 文件，路径基本上为 /etc/nginx/default.conf</p>',39),a=[d];function s(p,c,i,l,g,h){return o(),r("div",null,a)}const u=t(n,[["render",s]]);export{m as __pageData,u as default};
