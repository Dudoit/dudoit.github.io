# 跨域

我们在刚刚开始学习AJAX、Node或者练习一些项目实战的时候，HTTP请求是获取动态数据的重要一环，我猜大家肯定都遇到过令人头疼的跨域问题，第一次出现非代码程序的报错会让我们不知道如何下手，项目也无法继续进行；通常百度会帮助我们很快的解决掉这个问题，虽然项目能够进行下去了，但是我们的思绪还是一团麻，不知道什么时候什么原因出现会出现这个报错，我们下面就来看一下怎么梳开这个疙瘩。

几个关键词总结文章：`跨域`、`浏览器`、`同源策略`、`CORS`、`代理服务`、`Nginx反向代理`

## 跨域是什么？

这还不简单？什么是跨域，开局一张图。

（跨域飘红报错）

从上图可以看出，我们网站为 `http://localhost:8080` 的地址无法从 `http://localhost:3000` 获取数据

这时你不服气了，啪，甩给我一张图，看这不是请求成功了吗

（从apifox/postman中请求成功的图片）

听我解释呀，我们从Postman、Apifox中调试接口时能顺利拿到服务端提供的数据，但在控制台却给我们报错了呢，这说明我们的客户端即 **浏览器** 不能执行 `http://localhost:3000` 的 脚本

## 常见的跨域场景

|**URL**|**是否同域**|**说明**|
|-|-|-|
|http://www.dudoit.com\/**index.js**<br>http://www.dudoit.com\/**common.js**|**同域**|同一域名，同一文件夹|
|http://www.dudoit.com\/**a**/index.js<br>http://www.dudoit.com\/**b**/common.js|**同域**|同一域名，不同文件夹|
|http://www.dudoit.com/index.js<br>http://www.dudoit.com:**8000**/common.js|**不同域**|同一域名，**不同端口** <br>[ http默认80端口 ]|
|http://www.dudoit.com/index.js<br>http**s**:\//www.dudoit.com/common.js|**不同域**|同一域名，**不同协议**|
|http://www.dudoit.com/index.js<br>http://**api**.dudoit.com/common.js|**不同域**|主域名相同，**子域名不同**|
|http://www.dudoit.com/index.js<br>http://**dudoit.com**/common.js|**不同域**|同一域名，**不同二级域名**|
|http://www.dudoit.com/index.js<br>http://**123.123.85.27**/common.js|**不同域**|同一域名，**对应的IP**|
|http://www.dudoit.com/index.js<br>http://**www.baidu.com**/index.js|**不同域**|**不同域名**|

从上面的表格可以得知，共有 6 种情况会导致跨域的出现，分别是：

不同端口、不同协议、子域名不同、二级域名不同、不同域名、不同域（IP）

我们现在知道了xxx，那 **浏览器** 为什么不能执行不同域下即 跨域执行脚本 呢？

这是因为它自身携带了一本“防身指南”— **同源策略**

它是指网址中的协议、域名、端口三个都相同时才能互相访问，即若协议、域名、端口有其一不同时，浏览器禁止页面加载或执行与自身不同域的脚本

同源策略 的存在能够帮助**阻隔恶意文档**，**减少可能被攻击的媒介**。如果没有同源策略，我们网站的cookie等信息可能泄露，cookie一般是与服务端会话的重要凭证，可能会出现数据被盗取等后果。

其实，不只是你的 AJAX 请求无法被浏览器接收，同源策略的限制内容包括：

- Cookie、LocalStorage、IndexedDB 等存储在浏览器中的内容不能跨域访问
- DOM 节点不能跨域操作
- AJAX 请求被拦截

## 常见的跨域解决方法

将静态资源和API接口部署在同一个服务器

### CORS 跨域资源共享

> 跨源资源共享（CORS，或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。

CORS，全称 Cross-Origin Resource Sharing，跨域资源共享。

开启CORS的关键主要是服务端通过设置 `Access-Control-Allow-Origin` 的值处理跨域问题；例如，

```JavaScript
"Access-Control-Allow-Origin": "http://www.example.com"
```

在我看来这个相当于前端赋予服务端的一个令牌，服务端拿着这个令牌给浏览器，浏览器看了有前端域名签名的令牌，哟~原来是自家兄dei，快来快来。`*` 就更牛逼了，就像满江红里秦桧给张大的通行证一样，哪个浏览器还能不放行。

浏览器会自动进行CORS通信，但是即便CORS主要是在服务端配置的，CORS也需要浏览器和服务器同时支持才可以；目前所有浏览器都支持，具体浏览器兼容性可查看 [MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7)。

在面试中，CORS经常会拿来与JSONP做比较，它们两个的使用目的相同，但是CORS比JSONP更强大，看现在使用的频率就知道了。其次，在请求方式上，JSONP仅支持GET请求，而CORS支持所有类型的HTTP请求；在处理方式上，使用CORS，前端会非常开心，因为他不需要额外的改动；在兼容性方面，JSONP会更胜一筹。

### Node 代理服务

刚刚我们说了，同源策略是 **浏览器** 自身携带的“防身指南”；我们还说了，在Postman、Apifox等接口调试工具中都是可以完美请求到服务端传来的数据。那么，说明同为**服务端向服务端**请求就没有了同源策略的限制，- - 哈哈哈哈来来来都是“自家人”有什么可“防身”的，速速对酒当歌 🍻。

这里值得注意的是，**前端** 在请求 **node代理**服务时，由于端口不同或其他不同域的原因，还是会带上“防身指南”— 同源策略。所以，代理服务器 **依然需要开启CORS**，这样代理服务才能在拿到真实请求的数据后正确地返回给前端。

proxy

使用 node 进行

### Nginx 反向代理

Nginx反向代理一般在项目最后上线时在nginx服务器上开启；

开启方法和CORS跨域资源共享类似

在 Nginx 服务端上找到 default.conf 文件，路径基本上为 /etc/nginx/default.conf