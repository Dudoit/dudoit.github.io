## diff 算法

### 虚拟 dom

虚拟 dom 是一个用 JavaScript 来模拟真实 dom 的对象

```HTML
<!-- 真实 dom 结构 -->
<ul id='list'>
  <li class='item1'>111</li>
  <li class='item2'>222</li>
  <li class='item3'>333</li>
</ul>
```

```JavaScript
// 虚拟 dom 结构
const oldVDom = { 
  tagName: 'ul', // 标签名
  props: {  // 标签属性
    id: 'list' 
  },
  children: [ // 标签子节点
    { tagName: 'li', props: { class: 'item1' }, children: ['111'] },
    { tagName: 'li', props: { class: 'item2' }, children: ['222'] },
    { tagName: 'li', props: { class: 'item3' }, children: ['333'] },
  ]
}
```

- 虚拟 dom 解决了什么问题？

  在虚拟dom出现之前，我们都是jQuery一把梭（不多说了jQuery yyds）。

  这里先来了解一下浏览器的渲染原理：

  由图可以发现触发一次重排的代价还是比较大的；如果频繁触发浏览器的重排，无疑会造成很大的性能成本。
  我们都知道，在每一次事件循环后浏览器会有一个UI的渲染过程，那么在一次事件循环内触发的所有dom操作都会被当作为异步任务被放进异步任务队列中等待被处理。

  那么此例子只是更改了一次dom结构，如果更改100+次呢？

  虽然浏览器做了优化，在一段时间内频繁触发的dom不会被立即执行，浏览器会积攒变动以最高60HZ的频率更新视图；但是难免还是会造成一定次数的重排。

  这时候，虚拟dom就派上了用场：不管更改多少次，多少个地方的结构，都会映射到新的虚拟dom结构中去，然后进行diff的对比，最终渲染成真实的dom，在这一次render中只会操作一次真实的dom结构，所以只会造成一次重排。

  同时，采用JS对象去模拟DOM结构的好处是，页面的更新完全可以映射到JS对象中去处理，而操作内存中的JS对象速度也会更快。

- 虚拟 dom 的缺点

  首屏加载时间更长

  由于我们需要根据当前的节点，来生成对应的虚拟dom，我们都知道虚拟dom是一个JS对象，所以在项目初始化的时候去生成对应的虚拟节点也是一笔时间上的开销；因此项目的首次加载可能耗费更多时间

  极端场景下性能不是最优解

  栗子🌰：如果当前页面的节点基本全都改变了，那我们去做了一次diff的patch过程相当于做了无效操作；
